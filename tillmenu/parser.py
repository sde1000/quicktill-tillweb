import re

class Node:
    def __init__(self, parent, text, price, childindent=0):
        self.childindent = childindent
        self.parent = parent
        self.text = text
        self.price = price
        self.children = []

    @property
    def escaped_text(self):
        return self.text.replace('\\', '\\\\').replace('"', '\\"')

    def add_child(self, node):
        self.children.append(node)

    def output_as_menuitem(self):
        """Output this node as an item suitable for the top-level menu or
        a simplemenu"""
        if self.children:
            if self.price:
                return '("{}", subopts("{}", {}, [{}]))'.format(
                    self.escaped_text, self.escaped_text, self.price, ", ".join(
                        x.output_as_subopts() for x in self.children))
            else:
                # Output as simplemenu
                return '("{}", simplemenu([{}]))'.format(
                    self.escaped_text, ", ".join(
                        x.output_as_menuitem() for x in self.children))
        else:
            return '("{}", {})'.format(self.escaped_text, self.price or "0.00")

    def output_as_subopts(self):
        return '("{}", {})'.format(self.text, self.price or "0.00")

    def __str__(self):
        return "Node(text={}, price={}, children={})".format(
            self.text, self.price, ", ".join((str(x) for x in self.children)))

lm = re.compile(
    r"^(?P<indent>\s*)(?P<text>.*?)(\s*:\s*?(?P<price>\d+\.\d\d))?$")

class ParseError(Exception):
    pass

def text_to_tree(text):
    root = Node(None, "Root", None)
    parent = root
    line = 0
    for l in text.splitlines():
        line += 1
        l = l.rstrip()
        parts = lm.match(l)
        if parts is None:
            raise ParseError("Couldn't understand line {}; it says '{}'".format(
                line, l))
        d = parts.groupdict()
        indent = len(parts.group('indent'))
        text = parts.group('text')
        price = parts.group('price')
        if len(text) == 0:
            # Blank line
            continue
        if text[0] == '#':
            # Comment line
            continue
        if indent == parent.childindent:
            # We are adding a new child to the same parent - do nothing here
            pass
        elif indent > parent.childindent:
            # We are changing the parent to the most recent child of
            # the current parent
            parent = parent.children[-1]
            parent.childindent = indent
        else:
            # Find an ancestor that matches this indent level and go
            # back to it.  It's an error if there isn't one.
            while parent.childindent != indent:
                parent = parent.parent
                if not parent:
                    raise ParseError(
                        "Inconsistent indent level at line {}; it says '{}'"\
                        .format(line, l))
        parent.add_child(Node(parent, text, price))

    return root

def output_menu(root):
    return "menu = [{}]".format(
        ", ".join((x.output_as_menuitem() for x in root.children)))

boilerplate = """# -*- coding: utf-8 -*-
# This file is automatically generated using the web interface.
# Do not edit.

from quicktill.foodorder import simplemenu, subopts
from quicktill.models import zero

footer = "Your food will be brought to you."
print_total = False
dept = 16

def staffdiscount(tablenumber, item):
    return zero

"""
